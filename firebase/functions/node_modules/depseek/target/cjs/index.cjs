"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main/ts/index.ts
var index_exports = {};
__export(index_exports, {
  depseek: () => depseek,
  depseekSync: () => depseekSync,
  fullRe: () => fullRe,
  importRe: () => importRe,
  importRequireRe: () => importRequireRe,
  patchRefs: () => patchRefs,
  requireRe: () => requireRe,
  requireResolveRe: () => requireResolveRe
});
module.exports = __toCommonJS(index_exports);

// src/main/ts/depseek.ts
var fullRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)(require\s?(\.\s?resolve\s?)?\(\s?|import\s?\(?\s?)|\sfrom)\s?$/;
var importRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)import\s?\(?\s?|\sfrom)\s?$/;
var importRequireRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)(require\s?\(\s?|import\s?\(?\s?)|\sfrom)\s?$/;
var requireRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)require\s?\(\s?)\s?$/;
var requireResolveRe = /((\.{3}|\s|[!%&(*+,/:;<=>?[^{|}~-]|^)(require\s?(\.\s?resolve\s?)?\(\s?))\s?$/;
var isDep = (v, re) => !!v && re.test(v);
var isSpace = (v) => v === " " || v === "\n" || v === "	";
var isQ = (v) => `"'\``.includes(v);
var normalizeOpts = (opts) => __spreadValues({
  bufferSize: 1e3,
  comments: false,
  re: importRequireRe,
  offset: 19
}, opts);
var depseek = (stream, opts) => new Promise((resolve, reject) => {
  if (typeof stream === "string" || stream instanceof Buffer) {
    return resolve(depseekSync(stream, opts));
  }
  stream.setEncoding("utf8").on("readable", () => {
    resolve(extract(stream, opts));
  }).on("error", reject);
});
var depseekSync = (input, opts) => extract(readify(input.toString()), opts);
var patchRefs = (contents, patcher) => {
  const deps = depseekSync(contents);
  let pos = 0;
  let _contents = "";
  for (const { index, value } of deps) {
    _contents = _contents + contents.slice(pos, index) + patcher(value);
    pos = index + value.length;
  }
  return _contents + contents.slice(pos);
};
var readify = (input) => {
  const chunks = [null, input];
  return { read: () => chunks.pop() };
};
var extract = (readable, _opts) => {
  const { re, comments, bufferSize, offset } = normalizeOpts(_opts);
  const refs = [];
  const pushRef = (type, value, index) => refs.push({ type, value, index });
  let i = 0;
  let prev = "";
  let chunk;
  let c = null;
  let q = null;
  let token = "";
  let strLiteral = "";
  let commentBlock = "";
  let commentValue = "";
  while (null !== (chunk = readable.read(bufferSize))) {
    const len = chunk.length;
    let j = 0;
    while (j < len) {
      const char = chunk[j];
      if (c === q) {
        if (isSpace(char)) {
          if (!isSpace(prev)) token += char;
        } else if (prev === "/" && (char === "/" || char === "*")) c = char;
        else if (isQ(char)) q = char;
        else token += char;
      } else if (c === null) {
        if (isSpace(char) || isQ(char)) {
          if (strLiteral && isDep(token.slice(-offset), re)) pushRef("dep", strLiteral, i - strLiteral.length);
          strLiteral = "";
          token = "";
          q = null;
        } else strLiteral += char;
      } else if (q === null) {
        if (c === "/" && char === "\n" || c === "*" && prev === "*" && char === "/") {
          commentValue = c === "*" ? commentBlock.slice(0, -1) : commentBlock;
          if (commentValue && comments) pushRef("comment", commentValue, i - commentValue.length);
          commentBlock = "";
          token = token.slice(0, -1);
          c = null;
        } else if (comments) commentBlock += char;
      }
      prev = char;
      i++;
      j++;
    }
  }
  return refs;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  depseek,
  depseekSync,
  fullRe,
  importRe,
  importRequireRe,
  patchRefs,
  requireRe,
  requireResolveRe
});
